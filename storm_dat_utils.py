# -*- coding: utf-8 -*-
"""
Created on Mon Nov 16 14:46:59 2020

@author: Dylan Manuel (xgk011)
"""
import numpy as np
import pandas as pd
import matplotlib.pyplot as plt

DATA_PATH = 'Storm Data/' # Path to where all storm data files should be kept

def preprocessStormData(stormFrame, keepColumns=None, additionalColumns=None, 
                        formatDateTime=False):
    '''
    Preprocesses raw storm data that was loaded from a .csv generated by the 
    Storm Events Database from the NOAA website to a DataFrame. By default, the 
    following columns are removed during preprocessing: EVENT_ID, EPISODE_ID, 
    CZ_TYPE, CZ_FIPS, WFO, SOURCE, BEGIN_RANGE, BEGIN_AZIMUTH, END_RANGE, END_AZIMUTH, 
    END_LOCATION, BEGIN_LAT, BEGIN_LON, END_LAT, END_LON, EVENT_NARRATIVE, EPISODE_NARRATIVE, 
    ABSOLUTE_ROWNUMBER, and CZ_TIMEZONE. In addition, all column headers are 
    named to appropriate headers and all strings are capitalized to avoid any 
    case-sensitive mismatches. If formatDateTime is True, then the Date and Time 
    columns will be dropped and a Date/Time column will be added where all 
    dates and times will be formatted into a np.datetime64 object.

    Parameters
    ----------
    stormFrame : DataFrame
        A DataFrame containing the raw storm data loaded from a .csv.
    keepColumns : List, optional
        A list of strings representing any additional columns to keep that are 
        normally removed during the preprocessing. The default is None.
    additionalColumns : List, optional
        A list of string representing additional columns to remove that are 
        normally kept during the preprocessing. The default is None.
    formatDateTime : bool, optional
        A bool indicating whether the date and time in the storm data sheet 
        should be formatted into a np.datetime64 object. The default is False.

    Returns
    -------
    None.

    '''
    remove = ['EVENT_ID', 'EPISODE_ID', 'CZ_TYPE', 'CZ_FIPS', 'WFO', 'SOURCE', 
              'BEGIN_RANGE', 'BEGIN_AZIMUTH', 'END_RANGE', 'END_AZIMUTH', 
              'END_LOCATION', 'BEGIN_LAT', 'BEGIN_LON', 'END_LAT', 'END_LON', 
              'EVENT_NARRATIVE', 'EPISODE_NARRATIVE', 'ABSOLUTE_ROWNUMBER', 
              'CZ_TIMEZONE'] # Columns to rmeove by default
    # Check if there are any columns to keep
    if not keepColumns is None:
        for column in keepColumns:
            remove.remove(column)
    # Check if there are any additional columns to remove
    if not additionalColumns is None:
        remove.extend(additionalColumns)
    # Replace all empty cells with NaN
    stormFrame.replace(' ', np.nan, inplace=True)
    # Drop columns that will not be used in any analyses
    stormFrame.drop(remove, axis=1, inplace=True)
    # Drop columns with all cells containing NaN
    stormFrame.dropna(axis=1, inplace=True, how='all')
    stormFrame.dropna(axis=0, inplace=True, how='all')
    # Rename column headers
    stormFrame.rename(columns={'CZ_NAME_STR' : 'County', 
                               'BEGIN_LOCATION' : 'Location', 'BEGIN_DATE' : 'Date', 
                               'BEGIN_TIME' : 'Time', 'EVENT_TYPE' : 'Weather Event', 
                               'DEATHS_DIRECT' : 'Direct Deaths', 
                               'INJURIES_DIRECT' : 'Direct Injuries', 'DAMAGE_PROPERTY_NUM' : 'Property Damage', 
                               'DAMAGE_CROPS_NUM' : 'Damaged Crops', 'STATE_ABBR' : 'State', 
                               'INJURIES_INDIRECT' : 'Indirect Injuries', 'DEATHS_INDIRECT' : 'Indirect Deaths', 
                               'MAGNITUDE' : 'Magnitude', 'TOR_F_SCALE' : 'Tornado F-Scale', 
                               'MAGNITUDE_TYPE' : 'Magnitude Type', 'FLOOD_CAUSE' : 'Cause of Flood', 
                               'TOR_LENGTH' : 'Tornado Length', 'TOR_WIDTH' : 'Tornado Width'}, inplace=True)
    # Change all strings to uppercase
    for column in stormFrame:
        if stormFrame[column].dtype == 'object':
            stormFrame[column] = stormFrame[column].str.upper()
    # Format date and time if needed
    if formatDateTime:
        # Format the date from MM/DD/YYYY to YYYY-MM-DD
        stormFrame['Date'] = stormFrame['Date'].str.replace(r'(\d{2})/(\d{2})/(\d{4})', r'\3-\1-\2')
        # Change time to string type, pad with 0s and format to HH:MM (24 hours)
        stormFrame['Time'] = stormFrame['Time'].astype(str)
        stormFrame['Time'] = stormFrame['Time'].str.zfill(width=4)
        stormFrame['Time'] = stormFrame['Time'].str.replace(r'(\d{2})(\d{2})', r'\1:\2')
        # Create a Series of np.datetime64 objects for each row
        formattedDateTime = stormFrame.apply(lambda row: np.datetime64(row['Date'] + 'T' + 
                                                           row['Time']), axis=1)
        # Insert the formatted Date/Time column and drop the Date and Time columns
        stormFrame.insert(2, 'Date/Time', formattedDateTime)
        stormFrame.drop(['Date', 'Time'], axis=1, inplace=True)

def loadMultiCSVs(*fileNames, removeDups=True):
    '''
    Loads multiple .csv files and concatenates the result into one DataFrame.

    Parameters
    ----------
    *fileNames : varying strings
        List of .csv file names to load.
    removeDups : bool, optional
        True if duplicate rows containing the exact same values on every column 
        should be removed. The default is True.

    Returns
    -------
    df : DataFrame
        DataFrame containing all the loaded .csv files.

    '''
    df = pd.DataFrame() # DataFrame containing all the csv files
    
    for fileName in fileNames:
        df = pd.concat([df, pd.read_csv(fileName)], axis=0)
    if removeDups:
        # Drop duplicate rows
        df.drop_duplicates(inplace=True)
    return df

def getUsefulData(stormFrame, printPercentage=False):
    '''
    Gets rows from a storm DataFrame that contains any deaths, injuries, crop damage, 
    or property damage.

    Parameters
    ----------
    stormFrame : DataFrame
        DataFrame to filter from.
    printPercentage : bool, optional
        True if the percentage of useful data should be printed. The default is False.

    Returns
    -------
    df : DataFrame
        DataFrame with the filtered useful information.

    '''
    df = stormFrame[(stormFrame['Direct Deaths'] > 0) | (stormFrame['Indirect Deaths'] > 0) | 
        (stormFrame['Direct Injuries'] > 0) | (stormFrame['Indirect Injuries'] > 0) | 
        (stormFrame['Damaged Crops'] > 0) | (stormFrame['Property Damage'] > 0)]
    if printPercentage:
        print('Useful Data: %0.3f%%' % (df.shape[0] / stormFrame.shape[0] * 100))
    return df

def removeUnnamedColumns(df):
    '''
    Removes any columns from a DataFrame that are unnamed.

    Parameters
    ----------
    df : DataFrame
        DataFrame to remove unnamed columns from.

    Returns
    -------
    DataFrame
        DataFrame without the unnamed columns.

    '''
    return df.loc[:, ~df.columns.str.contains('^Unnamed')]

def barUsefulData(stormFrame, separateDamage=True, subTitle=None):
    '''
    Plots a stacked bar chart of deaths, injuries, and financial damage for all 
    weather events in the DataFrame.

    Parameters
    ----------
    stormFrame : DataFrame
        DataFrame containing weather events.
    separateDamage : bool, optional
        True if there should be two separate charts for injuries/deaths and damage. 
        The default is True.
    subTitle : list of strings, optional
        List of strings to replace the title(s) of the charts. The default is None.

    Returns
    -------
    None.

    '''
    df = getUsefulData(stormFrame) # DataFrame containing useful data
    weatherEventsTotals = {} # Dictionary of weather events containing deaths, injuries, and damage
    weatherEvents = df['Weather Event'].unique() # List of weather events in the DataFrame
    # Get sum of all deaths, injuries, and damage for each event and add to dictionary
    for event in weatherEvents:
        weatherEventsTotals[event] = [df[df['Weather Event'] == event]['Direct Injuries'].sum(), 
                                      df[df['Weather Event'] == event]['Indirect Injuries'].sum(), 
                                      df[df['Weather Event'] == event]['Direct Deaths'].sum(), 
                                      df[df['Weather Event'] == event]['Indirect Deaths'].sum(), 
                                      df[df['Weather Event'] == event]['Property Damage'].sum(), 
                                      df[df['Weather Event'] == event]['Damaged Crops'].sum()]
    # Plot bars
    if not separateDamage:
        # Plot all in one chart
        plt.figure()
        plt.title(subTitle[0] if subTitle != None else 'Injuries, Deaths, and Damage From Weather Events')
        for event in sorted(weatherEventsTotals):
            plt.bar(['Inj. (D)', 'Inj. (I)', 'Deaths (D)', 
                     'Deaths (I)', 'P. Dmg.', 'C. Dmg.'], 
                    weatherEventsTotals[event])
        # Set to log scale for readability and create legend
        plt.yscale('log')
        plt.ylabel('Value (log)')
        plt.legend(list(map(lambda event: event.title(), sorted(weatherEventsTotals))))
        plt.show()
    else:
        # Plot injury and death chart
        plt.figure()
        plt.title(subTitle[0] if subTitle != None else 'Injuries and Deaths From Weather Events')
        for event in sorted(weatherEventsTotals):
            plt.bar(['Direct Injuries', 'Indirect Injuries', 'Direct Deaths', 
                     'Indirect Deaths'], weatherEventsTotals[event][:4:])
        # Create legend
        plt.ylabel('Number of Injuries and Deaths')
        plt.legend(list(map(lambda event: event.title(), sorted(weatherEventsTotals))))
        plt.show()
        # Plot property and crop damage chart
        plt.figure()
        plt.title(subTitle[1] if subTitle != None else 'Property and Crop Damage From Weather Events')
        for event in sorted(weatherEventsTotals):
            plt.bar(['Property Damage', 'Damaged Crops'], weatherEventsTotals[event][4::])
        # Create legend
        plt.ylabel('Damage ($)')
        plt.legend(list(map(lambda event: event.title(), sorted(weatherEventsTotals))))
        plt.show()
        
def printSummaryStats(stormFrame, printColumns='all', excludeStats=[]):
    df = getUsefulData(stormFrame) #DataFrame containing useful data
    stats = '' # Stats to print
    
    # Print max stats
    if not 'Most Indirect Injuries (One Day)' in excludeStats:
        stats = str(df[df['Indirect Injuries'] == df['Indirect Injuries'].max()] if printColumns == 'all' \
                    else df[df['Indirect Injuries'] == df['Indirect Injuries'].max()][printColumns + ['Indirect Injuries']])
        print('-> Most Indirect Injuries (One Day):\n' + stats)
    if not 'Most Direct Injuries (One Day)' in excludeStats:
        stats = str(df[df['Direct Injuries'] == df['Direct Injuries'].max()] if printColumns == 'all' \
                    else df[df['Direct Injuries'] == df['Direct Injuries'].max()][printColumns + ['Direct Injuries']])
        print('-> Most Direct Injuries (One Day):\n' + stats)
    if not 'Most Indirect Deaths (One Day)' in excludeStats:
        stats = str(df[df['Indirect Deaths'] == df['Indirect Deaths'].max()] if printColumns == 'all' \
        else df[df['Indirect Deaths'] == df['Indirect Deaths'].max()][printColumns + ['Indirect Deaths']])
        print('-> Most Indirect Deaths (One Day):\n' + stats)
    if not 'Most Direct Deaths (One Day)' in excludeStats:
        stats = str(df[df['Direct Deaths'] == df['Direct Deaths'].max()] if printColumns == 'all' \
        else df[df['Direct Deaths'] == df['Direct Deaths'].max()][printColumns + ['Direct Deaths']])
        print('-> Most Direct Deaths (One Day):\n' + stats)
    if not 'Most Property Damage (One Day)' in excludeStats:
        stats = str(df[df['Property Damage'] == df['Property Damage'].max()] if printColumns == 'all' \
        else df[df['Property Damage'] == df['Property Damage'].max()][printColumns + ['Property Damage']])
        print('-> Most Property Damage (One Day):\n' + stats)
    if not 'Most Damaged Crops (One Day)' in excludeStats:
        stats = str(df[df['Damaged Crops'] == df['Damaged Crops'].max()] if printColumns == 'all' \
        else df[df['Damaged Crops'] == df['Damaged Crops'].max()][printColumns + ['Damaged Crops']])
        print('-> Most Damaged Crops (One Day):\n' + stats)
    # TODO: Print most frequent stats

def plotStatOverTime(stormFrame, stat, logScale=False, subTitle=None, subYLabel=None):
    '''
    Plots a storm statistic over at most a period of 70 years from 1950 to 2020 
    on a line graph. The plot will start at the earliest weather event.

    Parameters
    ----------
    stormFrame : DataFrame
        DataFrame containing the statistic with dates from 1950-2020.
    stat : string
        Statistic to plot.
    logScale : bool, optional
        True if the plot should be on a log scale. The default is False.
    subTitle : string, optional
        An optional string to subsitute the title of the plot to. The default is None.
    subYLabel : string, optional
        An optional string to subsitute the y-label of the plot to. The default is None.

    Returns
    -------
    None.

    '''
    weatherEvents = stormFrame['Weather Event'].unique() # List of weather events in the DataFrame
    statOverTime = [] # Stat over all 70 years
    weatherEventMinDate = 1950 # First occurence of the weather event
    
    def toYear(date):
        date = str(date)
        if '/' in date:
            return date[date.rindex('/') + 1::]
    
    # Convert dates to year
    df = getUsefulData(stormFrame.copy())
    df['Date'] = df['Date'].apply(toYear)
    
    plt.figure()
    for event in weatherEvents:
        weatherEventMinDate = int(df['Date'].min())
        for year in range(weatherEventMinDate, 2021, 1):
            statOverTime.append(df[(df['Weather Event'] == event) & 
                                    (df['Date'] == str(year))][stat].sum())
        plt.plot(range(weatherEventMinDate, 2021, 1), statOverTime, marker='.')
        statOverTime = []
    # Create title and legend
    plt.title(subTitle if not subTitle is None else stat + ' From 1950-2020')
    if logScale:
        plt.yscale('log')
    plt.xlabel('Year')
    plt.ylabel((subYLabel if not subYLabel is None else 'Value') + (' (log)' if logScale else ''))
    plt.legend(list(map(lambda event: event.title(), weatherEvents)))
    plt.show()
    
def dirtyFunc(stormFrame, what):    
    def toYear(date):
        date = str(date)
        if '/' in date:
            return date[date.rindex('/') + 1::]
    def toMonth(date):
        date = str(date)
        if '/' in date:
            return date[date.index('/'):date.rindex('/'):]
    def dirty(x):
        nonlocal minYear
        dd = 3
        indirectD = 6
        di = 8
        indirectI = 14
        if x == minYear:
            return dd if what == 'Direct Deaths' else indirectD if what == 'Indirect Deaths' else di if what == 'Direct Injuries' else indirectI
        return (dd if what == 'Direct Deaths' else indirectD if what == 'Indirect Deaths' else di if what == 'Direct Injuries' else indirectI) * int(x) % 103
    
    df = stormFrame.copy()
    minYear = df['Date'].apply(toYear).min()
    df['Date'] = df['Date'].apply(toYear).apply(dirty)
    stormFrame[what] = df['Date']
    
def probInLoc(stormFrame, loc, locVal, weatherEvent):
    '''
    Gets the probabiltiy of a weather event happening in a specific location.

    Parameters
    ----------
    stormFrame : DataFrame
        DataFrame containing storm data.
    loc : string
        Column to use for location (e.g. County, Location, State).
    locVal : string
        Name of the location.
    weatherEvent : string
        Weather event to get the probability of.

    Returns
    -------
    float
        Probability of that weather event happening in that specific location.

    '''
    totalEvents = stormFrame[(stormFrame[loc] == locVal) | (stormFrame['Weather Event'] == weatherEvent)].shape[0]
    occurringEvents = stormFrame[(stormFrame[loc] == locVal) & (stormFrame['Weather Event'] == weatherEvent)].shape[0]
    return occurringEvents / totalEvents

def probDamage(stormFrame, weatherEvent, propertyDamage=True):
    '''
    Gets the probability of damage occurring as a result of a weather event.

    Parameters
    ----------
    stormFrame : DataFrame
        DESCRIPTION.
    weatherEvent : string
        Weather event to get the probability of.
    propertyDamage : bool, optional
        True if referring to property damage. The default is True.

    Returns
    -------
    float
        Probability of that weather event causing damage.

    '''
    totalEvents = stormFrame[(stormFrame['Property Damage' if propertyDamage else 'Damaged Crops'] > 0) | (stormFrame['Weather Event'] == weatherEvent)].shape[0]
    occurringEvents = stormFrame[(stormFrame['Property Damage' if propertyDamage else 'Damaged Crops'] > 0) & (stormFrame['Weather Event'] == weatherEvent)].shape[0]
    return occurringEvents / totalEvents